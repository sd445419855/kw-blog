<!doctype html><html><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<title>WebSocket_项目实例合集之即时通讯</title>
    
<style id="wiz_custom_css">html, .wiz-editor-body {font-size: 12pt;}.wiz-editor-body {font-family: Helvetica, 'Hiragino Sans GB', '微软雅黑', 'Microsoft YaHei UI', SimSun, SimHei, arial, sans-serif;line-height: 1.7;margin: 0 auto;position:relative;padding: 20px 16px;}.wiz-editor-body h1,.wiz-editor-body h2,.wiz-editor-body h3,.wiz-editor-body h4,.wiz-editor-body h5,.wiz-editor-body h6 {margin:20px 0 10px;margin:1.25rem 0 0.625rem;padding: 0;font-weight: bold;}.wiz-editor-body h1 {font-size:20pt;font-size:1.67rem;}.wiz-editor-body h2 {font-size:18pt;font-size:1.5rem;}.wiz-editor-body h3 {font-size:15pt;font-size:1.25rem;}.wiz-editor-body h4 {font-size:14pt;font-size:1.17rem;}.wiz-editor-body h5 {font-size:12pt;font-size:1rem;}.wiz-editor-body h6 {font-size:12pt;font-size:1rem;color: #777777;margin: 1rem 0;}.wiz-editor-body div,.wiz-editor-body p,.wiz-editor-body ul,.wiz-editor-body ol,.wiz-editor-body dl,.wiz-editor-body li {margin:8px 0 0;}.wiz-editor-body blockquote,.wiz-editor-body table,.wiz-editor-body pre,.wiz-editor-body code {margin:8px 0;}.wiz-editor-body .CodeMirror pre {margin:0;}.wiz-editor-body a {word-wrap: break-word;text-decoration-skip-ink: none;}.wiz-editor-body ul,.wiz-editor-body ol {padding-left:32px;padding-left:2rem;}.wiz-editor-body ol.wiz-list-level1 > li {list-style-type:decimal;}.wiz-editor-body ol.wiz-list-level2 > li {list-style-type:lower-latin;}.wiz-editor-body ol.wiz-list-level3 > li {list-style-type:lower-roman;}.wiz-editor-body li.wiz-list-align-style {list-style-position: inside; margin-left: -1em;}.wiz-editor-body blockquote {padding: 0 12px;}.wiz-editor-body blockquote > :first-child {margin-top:0;}.wiz-editor-body blockquote > :last-child {margin-bottom:0;}.wiz-editor-body img {border:0;max-width:100%;height:auto !important;margin:2px 0;padding: 2px;vertical-align:bottom;}.wiz-editor-body table {border-collapse:collapse;border:1px solid #a7afbc;}.wiz-editor-body td,.wiz-editor-body th {padding:4px 8px;border-collapse:collapse;border:1px solid #a7afbc;min-height:28px;word-break:break-word;box-sizing: border-box;}.wiz-editor-body td > div:first-child {margin-top:0;}.wiz-editor-body td > div:last-child {margin-bottom:0;}.wiz-editor-body img.wiz-svg-image {box-shadow:1px 1px 4px #E8E8E8;}.wiz-editor-body .wiz-image-container {margin:0;max-width: 100%;display: inline-flex;flex-direction: column;}.wiz-editor-body .wiz-image-container .wiz-image-title {display:inline-block;text-align: center;color: #a7afbc;line-height: 18px;font-size: 12px;min-height: 18px;width: 100%;white-space: normal;}.wiz-hide {display:none !important;}.wiz-editor-body.wiz-editor-outline {padding-right:0; padding-left:0;}.wiz-editor-body.wiz-editor-outline .outline-container {margin:0; padding:0; line-height:1.5;}.wiz-editor-body.wiz-editor-outline .outline-container div {margin:0;}.wiz-editor-body.wiz-editor-outline .node {margin:0; padding: 0;}.wiz-editor-body.wiz-editor-outline .outline-container > .node {margin-right:24px; margin-left:30px;}.wiz-editor-body.wiz-editor-outline .node.collapsed .children {display:none;}.wiz-editor-body.wiz-editor-outline .node .row {position:relative; padding-left:26px;}.wiz-editor-body.wiz-editor-outline .node .operator-container {width:36px;position:absolute; top:4px; left:-18px;}.wiz-editor-body.wiz-editor-outline .node .operator-bar {position:absolute; top:0; left:0; right:0; bottom:0; display:flex; align-items:center; justify-content:center;}.wiz-editor-body.wiz-editor-outline .node .switch {width:18px; height:18px;display:flex;flex-direction: column;align-items: center;overflow: hidden;}.wiz-editor-body.wiz-editor-outline .node .switch i {font-size:20px;position:relative;left:-1px;top:-1px;}.wiz-editor-body.wiz-editor-outline .node .switch.active {cursor:pointer;color:transparent; transition:transform 200ms ease 0s;}.wiz-editor-body.wiz-editor-outline .node.collapsed .switch.active {transform:rotateZ(-90deg);}.wiz-editor-body.wiz-editor-outline .node .row:hover .switch.active {color:#505F79}.wiz-editor-body.wiz-editor-outline .node .dot {display:flex; align-items:center; justify-content:center; border-radius:100%; width:18px; height:18px;}.wiz-editor-body.wiz-editor-outline .node.collapsed .dot {background-color:rgba(80, 95, 121, .15);}.wiz-editor-body.wiz-editor-outline .node .dot-icon {background-color:#505F79; border-radius:100%; width:6px; height:6px;}.wiz-editor-body.wiz-editor-outline .node .child {margin-left:8px; border-left:1px solid #E6E9ED; padding-left:17px;}.wiz-editor-body.wiz-editor-outline .node .content {flex:1;outline:none; padding:4px 0;}.wiz-editor-body.wiz-editor-outline .node div.content {font-size:1rem;}.wiz-editor-body.wiz-editor-outline .node.complete > .row .content {text-decoration:line-through;color:#A7AFBC;}.wiz-editor-body.wiz-editor-outline .node .notes {outline:none; font-size:.8rem; color:#A7AFBC;}.wiz-editor-body.wiz-editor-outline .node .image {outline:none; padding-top:4px; padding-bottom:4px;}.wiz-editor-body.wiz-editor-outline .outline-container h1,.wiz-editor-body.wiz-editor-outline .outline-container h2,.wiz-editor-body.wiz-editor-outline .outline-container h3,.wiz-editor-body.wiz-editor-outline .outline-container h4,.wiz-editor-body.wiz-editor-outline .outline-container h5,.wiz-editor-body.wiz-editor-outline .outline-container h6 {margin:0;}body, .wiz-editor-body {  padding-left: 48px;  padding-right: 48px;}</style></head>

<body onload="parent.window.document.all.dd.height=document.body.scrollHeight" class="wiz-editor-body" data-wiz-document-type="common" spellcheck="false" style="">
  <div><div style="text-align: center;"><span data-wiz-span="data-wiz-span" style="font-size: 1.667rem;"><b></b></span></div><div style="text-align: center;"><span data-wiz-span="data-wiz-span" style="font-size: 1.667rem;"><b></b></span></div><div><br></div><div><br></div></div><div>标签：</div><div>&nbsp; &nbsp;&nbsp;Node.js 、Java 写 WebSocket 的接口</div><div>&nbsp; &nbsp; React、Vue 整合 WebSocket<br></div><div><br></div><div><div><div>涉及<span>其他</span>技术：</div><div>&nbsp; &nbsp;&nbsp;innerHTML</div></div><div><br></div></div><h1><br></h1><div><br></div><div><br></div><div><br></div><h1>项目实例 1：<span>聊天室之&nbsp;</span><span style="font-weight: bold;">React 整合 WebSocket</span></h1><blockquote></blockquote><div><b>技术栈：</b></div><div>&nbsp; &nbsp; 前端：React</div><div>&nbsp; &nbsp; 后端：未知后端语言 + WebSocket</div><div><br></div><blockquote></blockquote><div><b>来源：</b><br></div><div>&nbsp; &nbsp; 基于React和Nodejs实现多人共同在线编辑、编译代码小工具 - 代码黑板<br></div><div>&nbsp; &nbsp;<span>&nbsp;</span><a href="https://www.bilibili.com/video/BV1nb411u7ZY?from=search&amp;seid=11802774381748222592&amp;spm_id_from=333.337.0.0" style="text-decoration-skip-ink:none;">https://www.bilibili.com/video/BV1nb411u7ZY?from=search&amp;seid=11802774381748222592&amp;spm_id_from=333.337.0.0</a></div><div><br></div><div><b>前端实现方法：</b></div><div>&nbsp; &nbsp; 使用浏览器直接调用 WebSocket 实现。<br></div><blockquote><div><div><img src="WebSocket_项目实例合集之即时通讯_files/d91d39f3-c631-47e5-82eb-a23d3c2dde35.jpg"></div></div></blockquote><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><h1><span>项目实例 2：聊天室之&nbsp;</span>Spring 整合 WebSocket&nbsp;</h1><div><b>技术栈：</b></div><div>&nbsp; &nbsp; 前端：HTML + jQuery<br></div><div>&nbsp; &nbsp; 后端：Spring（Java）<br></div><div><br></div><div><b>来源：</b></div><div><blockquote><div>B站黑马老师&nbsp; &nbsp; JS + Java</div></blockquote><blockquote><blockquote><div><a href="https://gitee.com/userforgitee/websocket-demo" style="text-decoration-skip-ink:none;"><span style="color:rgb(0, 0, 0);">源码：</span>https://gitee.com/userforgitee/websocket-demo</a></div></blockquote></blockquote><blockquote><div><br></div></blockquote><blockquote><div>路人乙<span>&nbsp; &nbsp; JS + Java&nbsp; &nbsp;&nbsp;</span><span>B站黑马老师同款</span><span>&nbsp; &nbsp;&nbsp;</span></div></blockquote><blockquote><blockquote><div><span>源码：</span><a href="https://gitee.com/youngyajun/websocket-chatroom-demo" style="text-decoration-skip-ink:none;">https://gitee.com/youngyajun/websocket-chatroom-demo</a></div></blockquote></blockquote><div><blockquote><br></blockquote></div></div><div><br></div><div><b>前端实现方法：</b></div><div>&nbsp; &nbsp;&nbsp;<span>使用浏览器直接调用 WebSocket 实现。</span></div><div>&nbsp; &nbsp; 但值得注意的是：前端发起 WebSocket 连接调用的接口不是根路径 “/” 接口，而是 "/chat" 接口。</div><blockquote><blockquote><div><div><img src="WebSocket_项目实例合集之即时通讯_files/861652c6-a732-49f1-a12d-3715053b3fba.jpg"></div></div></blockquote></blockquote><div><div><br></div></div><div><br></div><div><span><b>后端实现方法：</b></span></div><blockquote><div>后端用 Java 写的，用的第三方 WebSocket 插件 socket.io 制作的 WebSocket 服务端功能。</div><div>具体的操作是用 Spring 的注解 @ ServerEndPoint 配置 WebSocket 服务到 "/chat" 接口上，没<span>用根路径，也没有</span>设置端口号，也没设置关联当前 Http Server。但是<span>只要访问这个接口，就建立一个 WebSocket&nbsp; &nbsp; 连接。</span></div><div><span><span>Java 版的&nbsp;</span>socket.io<span>&nbsp;配置 WebSocket 服务似乎比 Node 的更简便。</span></span><span><br></span></div></blockquote><blockquote><blockquote><div><div><img src="WebSocket_项目实例合集之即时通讯_files/8edb3745-b0ea-4b83-b64c-c786b18f4647.png"></div></div></blockquote><blockquote><div><div><br></div></div></blockquote></blockquote><blockquote><div><br></div></blockquote><div><br></div><div><br></div><div><br></div><h1>项目实例 3：<span>聊天室之&nbsp;</span>Vue 整合 WebSocket</h1><div><b>技术栈：</b></div><div>&nbsp; &nbsp; 前端：Vue<span><br></span></div><div>&nbsp; &nbsp; 后端：Node（JS）<br></div><div><span><br></span></div><div><span><b>来源：</b></span></div><div><div>&nbsp; &nbsp; github - 路人甲 Vue + Node.js 打造炫酷聊天室、留言板源码</div><div>&nbsp; &nbsp; <a href="https://github.com/chichengryota/ChattingRoom">https://github.com/chichengryota/ChattingRoom</a></div><div>&nbsp; &nbsp; &nbsp; &nbsp; 在线成品</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <a href="http://8.129.128.30:8000">http://8.129.128.30:8000</a> </div></div><div><br></div><div><span><br></span></div><div><span><b>前端实现方法：</b><br></span></div><div>&nbsp; &nbsp; 前端用<span>第三方 WebSocket 插件</span> socket.io 生成 WebSocket 客户端，而非浏览器内置的。</div><div style="text-align: left;">&nbsp; &nbsp; 值得注意的是，<span>socket.io<span>&nbsp;前端发起 WebSocket 连接指定的协议还是 <span data-wiz-span="data-wiz-span" style="background-color: rgb(127, 127, 127); color: rgb(255, 255, 255);">http</span>，而不是 </span></span><span style="color:rgb(255, 255, 255);background-color:rgb(127, 127, 127)" data-wiz-span="data-wiz-span">ws</span><span>。</span></div><div><span data-wiz-span="data-wiz-span">&nbsp; &nbsp;&nbsp;</span><span data-wiz-span="data-wiz-span" style="background-color: rgb(255, 255, 153);">不用浏览器内置 WebSocket 的原因是 socket.io 不是 WebSocket 规范的一对一的实现。</span><span><br></span></div><blockquote><blockquote><div><div><img src="WebSocket_项目实例合集之即时通讯_files/24d1def7-9364-4a0c-83d0-e25cad2f8fd5.png"></div></div></blockquote></blockquote><blockquote><blockquote><div><div><div><img src="WebSocket_项目实例合集之即时通讯_files/e0717a98-8496-4495-8039-1ce11dde87ae.png"></div></div></div></blockquote></blockquote><div><div>&nbsp; &nbsp;&nbsp;<br></div></div><div><blockquote><div><span>Q：为什么是服务器地址 BASE_URL 是 localhost ？</span></div></blockquote></div><blockquote><div><span>A：BASE_URL&nbsp;</span><span>里设置的</span><span>&nbsp;websocket 的接口地址是 localhost:4000，实际</span><span>调用的接口却是： 8.129.128.30:4000/，我推测，</span><span>估计前后端发布在一个服务器上，</span></div></blockquote><blockquote><blockquote><div><span>以用 localhost 的？不应该呀，websocket 请求是浏览器发出的请求呀，前后</span><span>端分离又不是让一个前端服务器直接访问后端服务器的接口。这里应该是在本地开发时没有改。</span></div></blockquote></blockquote><div><div><span>&nbsp; &nbsp;&nbsp;</span></div><blockquote><br></blockquote></div><div><br></div><div><b>后端实现方法：</b></div><blockquote><div><span>后端</span>用 Node.js 写的，用第三方 WebSocket 插件 socket.io 生成 WebSocket 服务端。</div><div>不过这里 WebSocket 服务端没有配置监听端口，而是和 http server 集成了，和 http server 共用一个端口。</div><div>http server 最后监听的是 4000 端口。</div></blockquote><blockquote><div><div><img src="WebSocket_项目实例合集之即时通讯_files/a71e3237-4b9f-48a0-8c12-3cba97857258.png"></div></div><div><div><div><img src="WebSocket_项目实例合集之即时通讯_files/9be62427-1830-44e3-98d8-3505d2804da2.png"></div></div></div></blockquote><div><div><br></div></div><blockquote><div>在后端的接口配置文件（router.js）中，没有<span>&nbsp;WebSocket 相关接口，也没设置根</span><span>路径 “/” 的接口</span></div><div><div><img src="WebSocket_项目实例合集之即时通讯_files/cf0b5371-3846-4933-9725-11dfa872fb83.png"></div></div></blockquote><div><div><br></div></div><blockquote><div><div><br></div></div></blockquote><div><blockquote><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><h1></h1><h1>项目实例 4：<span>聊天室之&nbsp;</span>Vue 整合 WebSocket（App）</h1><div><b>技术栈：</b></div><div>&nbsp; &nbsp; 前端：Vue<span><br></span></div><div>&nbsp; &nbsp; 后端：Node（JS）<br></div><div><br></div><div><b>来源：</b></div><div><div>&nbsp; &nbsp;&nbsp;bilibili - Vue + Node.js 即时通讯聊天室APP开发联调篇</div><div>&nbsp; &nbsp; <a href="https://www.bilibili.com/video/BV1uX4y1N7b1?p=15">https://www.bilibili.com/video/BV1uX4y1N7b1?p=15</a> </div><div><br></div></div><div><b>前端实现方法：</b></div></blockquote></div><blockquote><blockquote><div><span>注意，前端用</span><span>第三方移动端 WebSocket 插件</span><span><span>&nbsp;<span data-wiz-span="data-wiz-span" style="background-color: rgb(127, 127, 127); color: rgb(255, 255, 255);">weapp.</span></span><span data-wiz-span="data-wiz-span" style="background-color: rgb(127, 127, 127); color: rgb(255, 255, 255);">socket.io</span> 生成 WebSocket 客户端，而非浏览器内置的。</span></div></blockquote></blockquote><blockquote><blockquote><div><span>值得注意的是，</span><span>socket.io<span>&nbsp;前端发起 WebSocket 连接指定的协议还是<span>&nbsp;</span><span data-wiz-span="data-wiz-span" style="background-color:rgb(127, 127, 127);color:rgb(255, 255, 255);">http</span>，而不是<span>&nbsp;</span></span></span><span style="color:rgb(255, 255, 255);background-color:rgb(127, 127, 127)" data-wiz-span="data-wiz-span">ws</span><span>。</span><span><br></span></div></blockquote></blockquote><div><blockquote><div><span><br></span></div></blockquote></div><blockquote><div><blockquote><div><div>main.js</div></div></blockquote></div><div><blockquote><div><div><div><img src="WebSocket_项目实例合集之即时通讯_files/2061304109.jpg" width="605" height="329"></div></div></div></blockquote></div></blockquote><div><blockquote><div><div><br></div></div><div><br></div><div><br></div><div><br></div><div><b>后端实现方法：</b>&nbsp; &nbsp;&nbsp;</div></blockquote></div><blockquote><div><blockquote><div><div><span>后端</span>用 Node.js 写的，用第三方 WebSocket 插件 socket.io 生成 WebSocket 服务端。</div></div></blockquote></div><div><blockquote><div>不过这里 WebSocket 服务端配置了单独的监听端口，没有和 Http Server 共用一个端口。但他的操作还是有点迷，不直接用 Socket.IO 监听一个端口，而是用 Express 监听一个端口，再用 Socket.IO 监听 Express。</div><div>最后 Express 又监听了一个端口 3000，与 WebSocket 的不同。</div></blockquote></div></blockquote><div><blockquote><br></blockquote></div><blockquote><div><blockquote><div><div>yike.js</div></div></blockquote></div><div><blockquote><div><div><div><img src="WebSocket_项目实例合集之即时通讯_files/7f5bcc5f-36ea-4f43-b73f-4a982e9688d7.jpg" width="623" height="698"></div></div></div></blockquote></div><div><blockquote><div><div><div><br></div></div></div></blockquote></div><div><blockquote><div><div>yike.js<br></div></div></blockquote></div><div><blockquote><div><div><div><div><img src="WebSocket_项目实例合集之即时通讯_files/ff060b57-803a-44a8-8f8a-261d95c12498.jpg" width="736" height="523"></div></div></div></div></blockquote></div><div><blockquote><div><div><br></div></div><div><br></div><div><br></div><div><br></div></blockquote></div></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote></blockquote></blockquote></blockquote><blockquote><blockquote></blockquote></blockquote><blockquote></blockquote><div><div><b>移动端前端的的 web socket 插件—— weapp.socket.io&nbsp;</b></div></div><blockquote></blockquote><blockquote><div><div><div><img src="WebSocket_项目实例合集之即时通讯_files/3995d865-093b-4ae1-a37c-713ab29f5503.jpg" width="513" height="453"></div></div></div></blockquote><blockquote><div><blockquote><div><div><br></div></div></blockquote></div><div><blockquote><div><br></div></blockquote></div><div><blockquote><div><br></div></blockquote></div></blockquote><blockquote><div><br></div><div><br></div><div><br></div><h2>在该项目中关于下列 2 个问题的探究：</h2><div><ul><li><span>&nbsp;WebSocket 能不能像 http 那样，能根据 url 来处理不同的业务？</span></li><li><span>WebSocket Server 和 Http Server 能否使用同一端口？</span></li></ul><div><br></div><div><br></div><h3><b>一、先来看看 socket.io 官方使用说明：</b></h3></div></blockquote><blockquote><div><blockquote><div>后端使用方法：</div></blockquote></div></blockquote><blockquote><div><blockquote><div><div><img src="WebSocket_项目实例合集之即时通讯_files/74e3e4fe-e980-41a5-8dbc-ec677714f5c6.jpg" width="872" height="507"></div></div></blockquote></div></blockquote><blockquote><blockquote><div><blockquote><div><div>&nbsp; &nbsp; Q：这个 path 是否可以设置像接口路径一样的访问路径？</div></div></blockquote></div></blockquote><blockquote><div><blockquote><div>&nbsp; &nbsp; A：（<span>暂不深究）</span></div><div><span><br></span></div></blockquote></div></blockquote></blockquote><div><blockquote><div><div><div><div><img src="WebSocket_项目实例合集之即时通讯_files/2b2e88cb-b6e0-4b3c-a49e-0cb8e0be379d.jpg" width="814" height="473"></div><div><br></div></div></div><div><br></div><div>从上面 socket.io 官方使用说明的代码可以看出：</div></div></blockquote></div><blockquote><div><blockquote><div><div>express 负责拦截请求，http 负责监听端口，socket 负责监听 socket 连接。<span data-wiz-span="data-wiz-span" style="background-color: rgb(127, 127, 127); color: rgb(255, 255, 255);">监听端口只设置了一个 3000</span>，那说明后端接口和websocket 可以共用一个端口吗？这个问题要看应用级别还是协议级别。多个应用是不能监听一个端口的，但是一个应用中的多个协议是可以共用一个端口的。而且实践证明，socket、express 接口都可以只用这一个 3000 端口访问。</div></div></blockquote></div></blockquote><blockquote><div><div><br></div></div></blockquote><blockquote><blockquote><div><span>上述代码用了装饰器模式，例如</span><span>给原本孤单 express 增加了一些伙伴（功能），如</span><span>&nbsp;http、socket.io。但各自的引用都保留了下来，以便让它们执行各自的操作。整合后的结构如下：</span></div></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><div style="text-align: left;"><span>socket( </span><span style="color:rgb(255, 255, 255);background-color:rgb(127, 127, 127)" data-wiz-span="data-wiz-span">http</span><span>( express ) )</span></div></blockquote></blockquote></blockquote><blockquote><blockquote><div><blockquote><div><span>&nbsp; &nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |</span></div></blockquote></div></blockquote></blockquote><blockquote><blockquote><div><blockquote><div><span>引用1&nbsp; &nbsp;引用2&nbsp; &nbsp; 引用3</span></div></blockquote></div></blockquote></blockquote></blockquote><blockquote><div><br></div><div>可是为什么要用 http 包裹 express，express 的底层不就是 express 吗？</div><div>&nbsp; &nbsp; 这个原因<span data-wiz-span="data-wiz-span" style="background-color: rgb(127, 127, 127); color: rgb(255, 255, 255);">以后求证</span>，但可以知道的是，不这么做，socket 就不能跟 express 关联成功，<span data-wiz-span="data-wiz-span" style="background-color: rgb(255, 255, 153);">http 在 express 和 socket 之间起到了一个桥梁的作用</span>。</div><div>&nbsp; &nbsp; 在这里不得不佩服 socket.io 的开发人员，这个方式是在socket.io 官方文档的用法中出现的，在 websocket-ws 官方文档中没有，不过也行得通。<br></div><div><br></div><div><div><div>至于之前的推测：“因为它可能只是提供相同端口以便前端调用，在建立 WebSocket 连接时可能另外再监听一个端口”，这个现在可以确认了，他们通过装饰器模式，让一个应用进程有了多个应用的功能，所以多个应用之间能共享一个端口。</div></div><div><br></div></div><div><br></div><div><br></div><div><b>小结：</b></div><div>&nbsp; &nbsp; 1、Node.js 中 websocket 关联外部服务器使用同一端口的方法（适用于 ws、socket-io）：<br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; websocket 套 http 套 express</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; Remark：websocket 直接套 express 行不通，必须把 http 作为中间桥梁。</div><div>&nbsp; &nbsp;&nbsp;<br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div></blockquote><h3><b>二、再来看看该项目示例：</b></h3><blockquote></blockquote><div><div><span>后端使用方法：</span></div></div><blockquote><div><blockquote><div>yike.js<br></div></blockquote></div><div><blockquote><div><div><img src="WebSocket_项目实例合集之即时通讯_files/7f5bcc5f-36ea-4f43-b73f-4a982e9688d7.jpg" width="537" height="603"></div></div></blockquote></div><div><blockquote><div><div><br></div></div></blockquote></div><div><blockquote><div><div>yike.js</div></div></blockquote></div><div><blockquote><div><div><div><img src="WebSocket_项目实例合集之即时通讯_files/ff060b57-803a-44a8-8f8a-261d95c12498.jpg" width="646" height="459"></div></div></div></blockquote></div></blockquote><div><blockquote><div><div>上述代码中，</div></div></blockquote></div><blockquote><div><blockquote><div><span>server = app.listen(8082)</span></div></blockquote></div><div><blockquote><div><span>app.listen(3000)</span><span>&nbsp;</span></div></blockquote></div></blockquote><div><blockquote><div>express 首先监听 8082，最后又再次监听 3000？<span>为什么要这么操作？</span></div><div><span>&nbsp; &nbsp; <span data-wiz-span="data-wiz-span" style="background-color: rgb(127, 127, 127); color: rgb(255, 255, 255);">作者解释</span>：socket 要有独立的端口。</span></div><div>&nbsp; &nbsp; <font color="#ffffff"><span style="background-color: rgb(127, 127, 127);">个人看法</span></font>：持怀疑态度。</div><div><br></div><div><br></div><div>端口占用情况：</div><div>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;<span>前端端口是 8080</span><br></div></blockquote></div><blockquote><blockquote><blockquote><blockquote><div><blockquote><div>&nbsp; &nbsp;&nbsp;<img src="WebSocket_项目实例合集之即时通讯_files/285e9172-a08e-4558-8b52-02e0559d5d26.jpg" width="426" height="373"></div></blockquote></div></blockquote></blockquote></blockquote></blockquote><div><blockquote><div><div>&nbsp; &nbsp; 后端<span>端口</span>：3000</div><div><br></div><div>&nbsp; &nbsp; 后端 WebSocket <span>端口</span>： 8082</div></div></blockquote></div><blockquote><blockquote><blockquote><blockquote><div><blockquote><div><div><div><div><img src="WebSocket_项目实例合集之即时通讯_files/a0c54c64-8c08-496d-b75d-22474cdba47e.jpg"></div></div></div></div></blockquote></div></blockquote></blockquote></blockquote></blockquote><div><blockquote><div><div><div><br></div></div></div></blockquote></div><div><blockquote><div><div><br></div><div>路由表（<span>接口映射，类似 Controller）配置：</span></div></div></blockquote></div><blockquote><div><blockquote><div><div>index.js</div></div></blockquote></div><div><blockquote><div><div><div><img src="WebSocket_项目实例合集之即时通讯_files/b5c914e3-9f16-42ff-9b70-829e5db506ed.jpg" width="725" height="659"></div></div></div></blockquote></div></blockquote><div><blockquote><div><div><br></div></div><div>对接数据库的配置</div></blockquote></div><blockquote><div><blockquote><div>dbserver.js</div></blockquote></div><div><blockquote><div><div><img src="WebSocket_项目实例合集之即时通讯_files/94458eab-498b-4d8f-9097-bbef731f04b0.jpg" width="747" height="558">··</div></div></blockquote></div></blockquote><blockquote><div><blockquote><div><div><br></div></div></blockquote></div><div><blockquote><div>server/index.js</div></blockquote></div><div><blockquote><div><div><img src="WebSocket_项目实例合集之即时通讯_files/a07795bb-5aa8-44eb-a599-4df55b42e2c4.jpg" width="830" height="516"></div></div></blockquote></div></blockquote><div><blockquote><div><div><br></div></div><div><br></div><div><br></div><div><br></div><div><br></div></blockquote><div><h3><b>三、总结：</b></h3></div><blockquote></blockquote></div><blockquote><div><div>端口占用情况：</div></div><div>&nbsp; &nbsp; 前端：8080</div><div>&nbsp; &nbsp; 后端：3000</div><div>&nbsp; &nbsp; 后端 WebSocket： 8082</div><div><br></div><div>连接 WebSocket 的方式：</div><div>&nbsp; &nbsp;<span>&nbsp;</span><a href="http://......:8082" style="text-decoration-skip-ink:none;">http://......:8082</a></div><div><br></div><div>后端支持 WebSocket 的方式：</div><div>&nbsp; &nbsp; express 先监听 8082，socket.io 监听这个 express</div><div>&nbsp; &nbsp; express 再监听 3000</div><div><br></div><div><br></div><div><br></div></blockquote><h3><b>四、2 个问题的探究结果</b></h3><blockquote><div><b>Q：WebSocket 能不能像 http 那样，能根据 url 来处理不同的业务？</b><br></div><div>结论：在这个 Node 写的后台里，它没有这么做，它还是给 WebSocket 服务另外分配个端口。只有 Java 写的后台里用的 url。但不知道底层是否另外用了一个端口来做 WebSocket 连接。<br></div><div><br></div></blockquote><blockquote><div><div><span><b>Q：WebSocket Server 和 Http Server 能否使用同一端口？</b></span></div></div><blockquote></blockquote><div><span>结论：从表面使用的方面看是可以的，至于底层是不是用端口转发实现的无关紧要，暂不深究。</span></div></blockquote><blockquote><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><h1>项目实例大合集：</h1><div><br></div><div><b>聊天室：</b><br></div><div><div>&nbsp; &nbsp; cnblogs - 9、socket.io,websocket 前后端实时通信,(聊天室的实现)</div><div>&nbsp; &nbsp;<span>&nbsp;</span><a href="https://www.cnblogs.com/zhongchao666/p/9347016.html" style="text-decoration-skip-ink:none;">https://www.cnblogs.com/zhongchao666/p/9347016.html</a></div><div>&nbsp; &nbsp; cnblogs - 基于Node.js + WebSocket 的简易聊天室（<span>WebSocket 插件：</span>Socket.IO）</div><div>&nbsp; &nbsp;<span>&nbsp;</span><a href="https://www.cnblogs.com/demodashi/p/9442972.html" style="text-decoration-skip-ink:none;">https://www.cnblogs.com/demodashi/p/9442972.html</a><span>&nbsp; &nbsp;&nbsp;</span></div><div>&nbsp; &nbsp; bilibili - 基于React和Nodejs实现多人共同在线编辑、编译代码小工具 - 代码黑板<span>（</span><span>WebSocket 插件：WebSocket-WS</span><span>）</span></div><div>&nbsp; &nbsp; <a href="https://www.bilibili.com/video/BV1nb411u7ZY">https://www.bilibili.com/video/BV1nb411u7ZY</a><span>&nbsp; &nbsp;&nbsp;</span></div><div>&nbsp; &nbsp; bilibili - WebSocket打造在线聊天室【完结】（B站黑马老师）<span>（JS + Java，</span><span>WebSocket 插件：</span><span>Socket.IO</span><span>）</span></div><div>&nbsp; &nbsp; <a href="https://www.bilibili.com/video/BV1r54y1D72U?p=3">https://www.bilibili.com/video/BV1r54y1D72U?p=3</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 源码1：B站黑马老师（JS + Java）</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <a href="https://gitee.com/userforgitee/websocket-demo">https://gitee.com/userforgitee/websocket-demo</a></div><div>&nbsp; &nbsp; &nbsp; &nbsp; 源码2<span>：</span>路人乙（照敲老师视频代码）（JS + Java）&nbsp; &nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 源码：<a href="https://gitee.com/youngyajun/websocket-chatroom-demo">https://gitee.com/youngyajun/websocket-chatroom-demo</a></div><div>&nbsp; &nbsp; github - 路人甲 Vue + Node.js 打造炫酷聊天室、留言板源码<span>（</span><span>WebSocket 插件：</span><span>Socket.IO）</span></div><div>&nbsp; &nbsp; <a href="https://github.com/chichengryota/ChattingRoom">https://github.com/chichengryota/ChattingRoom</a> </div><div>&nbsp; &nbsp; &nbsp; &nbsp; 在线成品<br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; <a href="http://8.129.128.30:8000">http://8.129.128.30:8000</a><span>&nbsp; &nbsp;&nbsp;</span></div><div>&nbsp; &nbsp; bilibili - Vue + Node.js 即时通讯聊天室APP开发联调篇<span style="font-size:0.833rem" data-wiz-span="data-wiz-span">（Node 后台内容较全面，讲得不是很好，但代码敲出来了，功能实现了，因此还是</span><span data-wiz-span="data-wiz-span" style="color: rgb(255, 255, 255); background-color: rgb(127, 127, 127); font-size: 0.833rem;">推荐阅读</span><span style="font-size:0.833rem" data-wiz-span="data-wiz-span">的）</span></div><div>&nbsp; &nbsp; <a href="https://www.bilibili.com/video/BV1uX4y1N7b1?p=15">https://www.bilibili.com/video/BV1uX4y1N7b1?p=15</a>&nbsp;<span>（</span><span>WebSocket 插件：</span><span>Socket.IO）</span></div><div>&nbsp; &nbsp; bilibili - 『WebSocket』从JS到Vue2/3系列课程合集（WebSocket 插件：WebSocket-WS）（小野老师）</div><div>&nbsp; &nbsp; <a href="https://www.bilibili.com/video/BV1jy4y1U7UE">https://www.bilibili.com/video/BV1jy4y1U7UE</a><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span></div><div>&nbsp; &nbsp; 【WebSocket】利用nodejs和websocket做一个简单的聊天室<span>（WebSocket 插件：Nodejs-Websocket）</span></div><div>&nbsp; &nbsp; <a href="https://www.bilibili.com/video/BV1Lx41157Nv?p=3">https://www.bilibili.com/video/BV1Lx41157Nv?p=3</a> </div><div><br></div><div><br></div></div></blockquote>
  <script type="text/javascript">
    /**
     * 让 iframe 中的 <a> 打开新页面
     */
    let aDoms = document.getElementsByTagName("a")
    for ( let aDom of aDoms ) {
      let oldHref = aDom.href;
      let newHref = "javascript:window.open('" + oldHref + "')";
      // console.info("aDom", aDom);
      aDom.href = newHref;
    }
  </script>
  
</body></html>